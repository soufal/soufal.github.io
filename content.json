{"meta":{"title":"行寂静行","subtitle":"Soufal's Blog","description":"Soufal's Blog","author":"Soufal","url":"http://soufal.cn"},"pages":[{"title":"[404]","date":"2018-06-28T03:07:50.300Z","updated":"2018-06-28T03:07:50.300Z","comments":true,"path":"404.html","permalink":"http://soufal.cn/404.html","excerpt":"","text":""},{"title":"About Me","date":"2018-06-28T03:06:53.000Z","updated":"2018-06-28T03:06:53.000Z","comments":true,"path":"about/index.html","permalink":"http://soufal.cn/about/index.html","excerpt":"","text":""}],"posts":[{"title":"paper note","slug":"paper-note","date":"2018-06-27T03:25:15.000Z","updated":"2018-06-28T03:26:15.777Z","comments":true,"path":"2018/06/27/paper-note/","link":"","permalink":"http://soufal.cn/2018/06/27/paper-note/","excerpt":"","text":"Prediction of Prediction of off-target activities for the end-to-end design of CRISPR guide RNAs摘要：脱靶效应可导致次优基因编辑结果，是其发展的瓶颈。使用基于两个相互关联的机器学习模型的方法来预测脱靶效应—叫做Elevation。 对独立的guide-target 对进行评分，然后同时将他们合并为一个唯一整体总结指导分数。还提出了一张评估方法用于：平衡活动和非活动guide之间的误差 背景：减少脱靶影响最好的方式是：知道他们什么时候，在哪发生，并在平衡on-target效率的情况下设计一个指南来避免脱靶。 本文提出了基于机器学习的方法： 基于机器学习的预测建模可以利用少量的数据来了解导致脱靶效应的gRNA-target序列对的统计规律，以及它们对细胞的总体影响。这种建模使得能够廉价和快速地在全基因组水平上筛选非试验前的gRNA的脱靶效应。 本文方法：对于脱靶预测建模有两种主要的用例：1，了解给定的脱靶区域可能对特定的gRNA来说有多活跃，这个活跃性称之为gRNA-target评分。（对于关注基因组的特定区域来说是很有用的）2，获得给定的gRNA的所有脱靶活性的总体得分，以获得基因的潜在gRNA排序。 可以将脱靶预测模型问题分解成三个主要的任务： 搜索并过滤全基因组以获得一个gRNA的潜在靶点。 （例如，基因组中与gRNA相匹配的区域中，可能有N个目标位点的核苷酸误匹配，这些位点将会在第二步以后才会被视为脱靶活性，使用机器学习去区分有活性的和无活性的targets。在这一步只会创建一个潜在活性位点的简短列表。） 对每一个潜在活动目标进行评分，给gRNA-target对分配一个数值，来表示一个gRNA-target对预计有多少脱靶效应。 对（2）中的分数进行合并，得到一个单独的脱靶可能性，用于评估gRNA。 在第一步的搜索和过滤任务中，可以使用数值方法：Cas-OFFinder, CRISPOR, CHOP-CHOP,e-CRISPR， CRISPR-DO, CROP-IT and COSMID。（所算法使用的搜索算法不同，以及有着不同的搜索完整性。） 搜索完整性：取决于诸如最大不匹配数量，允许的原型间隔符相邻基序（PAM）和所使用的搜索算法。 本文中，在第一步中使用了自己的系统作为搜索和过滤操作—-Elevation-search。 第二步和第三步使用所提出的—脱靶的端对端建模方法为Elevation ： 对于gRNA-target评分：开发出一个双层回归模型（Elevation-score）： 第一层学习预测单个错配（target与预期的target之间，因此也包括替代的PAM）脱靶活性。 第二层模型学习如何将来自具有多个错配的gRNA-target对的单错配模型的预测组合成单个gRNA-target得分—-‘combiner’模型。 为了汇总guide的单个评分： 首先将gRNA-target评分模型应用于潜在的target列表（通过Elevation搜索列出）。 然后再使用Elevation-汇总模型来对单个的评分进行汇总。*Elevation模型：考虑每一个潜在的target是否位于基因中，并允许这些特征和其他特征通过非线性建模方法（boosted 回归树）相互作用。 下图为Elevation脱靶预测模型的框架图： 第一层a： 首先gRNA-target对被分解为两个单个误匹配pseudo-pairs（{}$t_1,g_1$},{$t_2,g_2$})，每一对可以通过第一层（单个误匹配）模型来获得评分$f$。 然后这些单个的评分通过第二层模型进行组合，生成一个解释所有误匹配的单个gRNA-target评分。 第二层b： 计算gRNA-target评分的输入分布的统计作为特征，并通过模型运行产生一个gRNA的聚合评分。 特征选择：对于第一层（单个误匹配）特征选择： 误匹配的位置. 误匹配的nucleotide（核苷酸）一致性(the nucleotide identity）. 单个特征中无匹配的联合位置和身份. 突变是否是一个转换或者颠换。 第二层（多个误匹配组合器）模型： 特征重要性显示误匹配的总数，以及第一层单个误匹配预测的总和在驱动了这个模型。 聚合的最后任务：获得对于一个gRNA所给定的所有单个gRNA-target评分的单个脱靶总结评分。该任务的解决方案对于gRNA的设计非常有用，在于用户想要扫描大量的gRNA的总体活性。 细胞的活力部分由每个细胞的DNA断裂数决定。第二个对活性的影响是在一个关键基因上的脱靶活性。 核染色质开放性–真核生物染色质DNA在核小体或转录因子等蛋白与其结合后，对其他蛋白能否再结合的开放程度。这一特征反应了染色质转录活跃程度。（这部分不太清楚，应该是在介绍核染色质对实验的影响？） 研究方法：数据： 训练第一层，使用CD33数据。 评估第二层，使用两个无偏/全基因组多误匹配数据集。 单个gRNA靶对评分的预测模型：先介绍CFD模型所作出的假设，再描述Elevation评分模型以及他怎么在概念上与CFD相关联的。 CFD模型（预测脱靶模型）： 首先计算CD33数据中每种单个错配类型的gRNA-target对活性的观测频率（observed frequency）。 然后针对有多个误匹配的gRNA-target对，CFD通过将单个错配频率乘到一起进行组合。 例如，如果gRNA-target对在位置3处有A：G误匹配，在位置5处有T：C误匹配，并且在目标区域有“CG”的PAM存在，则CFD将会计算这个gRNA的脱靶评分为：$CFD \\ score=P(active | A:G,3) \\times P(active | T:C,5) \\times P(active | CG)$ 这些项每个都是根据CD33训练集数据中（只包含单个误匹配或备用PAM，但是不会同时包含两者）观察到的频率来计算的。 CFD作为朴素贝叶斯：可以把CFD算法解释为分类模型—朴素贝叶斯。 $Y=1$表示一个gRNA-target对有活性，$Y=0$表示这个对没有活性。 用$X_i$表示特征比如（T:G，5），$i$简单的指示了这些特征的枚举（即一个one-hot编码）。如果特征（误匹配）发生—-$X_i=1$，如果没有发生—-$X_i=0$。因此，在CD33数据集中（只有单个误匹配），一个特殊的gRNA-target对仅有一个$X_i=1$，其他的都为$X_i=0$。在这个定义下，可以重写针对一个gRNA-target对的CFD为：$CFD=\\prod_{i\\in{i | X_i=1}} \\ P(Y=1 | X_i=1)$。 贝叶斯模型将会计算在给定的特征值下，一个gRNA-target对是有活性的概率为： $Naive Bayes \\equiv P(Y=1 |{X_j})=\\frac{P(Y=1)}{P({X_j})}) \\prod_i P(X_i | Y=1)$ 其中，$X_j$为所有特征$X_i$的集合。假设在gRNA是有活性的情况下，特征$X_i$是独立的使得：$P({X_j}|Y=1)=\\prod_iP(X_i|Y=1)$。使用Bayes规则，可以重写朴素贝叶斯分类器为： $NaiveBayes\\equiv P(Y=1|{X_j})=\\frac{P(Y=1)}{P({X_j})}\\prod_iP(Y=1|X_i)\\frac{P(X_i)}{P(Y=1)}=\\frac{1}{P({X_j})}\\prod_iP(Y=1|X_i)P(X_i)$ 如果做出两个更近一步的假设，会发现朴素贝叶斯分类器恰好与CFD匹配。第一个假设假设特征略微独立，也就是说：$\\prod_iP(X_i)=P({X_j})$，在这种情况下，朴素贝叶斯可以简化为： $NaiveBayes_{feat.ind.}=\\prod_iP(Y=1|X_i)$ 在Elevation-score中也可以做出同样的假设。如果假设$P(Y=1|X_i=0)=1$，那么CFD和朴素贝叶斯将会是独立的。关键的问题是询问训练数据集的那些属性能够推广到模型可能应用的不可见数据集中。特别地，可以有理由的假设$P(Y=1|X_i=1)$是一个可以推广到其他数据集的quality。这个quality反映了我们观察到一种特定类型的不匹配的情况下gRNA的活跃可能性。因此他与在训练与测试集中不匹配类型的分布无关。定义了在没有观察到特征的情况下，gRNA是活跃的可能性。 CFD假设为$P(Y=1|X_i=0)=1$。 Elevation-score作为两层堆栈回归： 可以从CFD中推广出三种主要的方式： 使用回归代替分类器。 增大了特征空间。 组合使用机器学习方法取代了乘法结合概率的先验方法。 模型值执行前两步，具体方法为： 首先将CD33LFC数值转换为位于范围内。他们可以被解释成概率，再使用核密度估计器将每个LFC变换成核密度估计中的LFC的累积密度。在这里使用高斯核并通过tenfold cross-validation（十倍交叉验证）来选择频率长度。 Elevation-score被分为两层： 第一层对gRNA-target对中的单个误匹配进行预测（第一层单个误匹配回归模型）$p(y|{X_j})$： 使用boosted regression trees（boosted回归树）（使用scikit-learn库的默认配置）在CD33数据集上执行。由于每个gRNA-target对在这些数据上只有一个$X_i=1$，也可以使用线性回归模型来进行预测。但是希望gRNA-target对更加丰富。因此希望这些特征能够在一个非线性方法中相互影响。特别地，会使用特征的“解耦”版本，比如编码形式之一‘A:G’—-这是one-hot。还有其他位置的整数特征。CFD是将这些组合在一起作为一个单独的特征。还包括突变是否是颠倒或过渡。使用这些改进的并组合每一个误匹配的模型，正如CFD所作的将这些值相乘一样—-Elevation-naive。 第二层组合这些多个误匹配： 我们将Elevation-score的第二层作为组合器，因为它学习如何以更细致的方式将来自单个不匹配模型的预测结合起来，而不是简单地将它们相乘，从而允许减轻某些陈述的假设。 使用数据驱动及其学习方法来调整如何去组合他们。使用第一层boosted回归树模型J次来对J个单个gRNA-target对进行预测（也就是说，J个特征有着$X_j=1$），产生J个预测$\\hat{y}_i \\in [0,1]$(每一个特征有$X_j=1$,并且针对剩余的K个有着的$X_k=0$特征设置$\\hat{y}_k =1$)。每一个gRNA-target对有$T=J+K=21$个boosted回归树预测。（20个可能的误匹配位置和一个PAM）作为特征。这21个特征的$log$:${log(\\hat{y_t})}$以及他们的总和，乘积和J（误匹配数和PAM数）作为第二层模型L1正则线性回归模型的输入。 最后，因为我们最终想要的是对gRNA-target对进仓库有效的可能性的预测，我们还要对来自L1回归组合器模型的输出应用了一个最终变换。通过一个校准模型来转换输出。 校准模型使用逻辑回归模型使用Elevation-naive训练得到的预测作为输入来估计$P(active|GUIDE \\ - \\ seq \\ normalized \\ counts)$，然后使用相对应的二值观测活性（LFC&gt;1)作为目标变量。—–只有回归的表现会影响这个转换，同gRNA-target评分无关。（即使是很简单的线性变换也可能会改变聚合分数。） Elevation-聚合：Elevation-score值提供了选择具有最小期望脱靶活性的gRNA的初始条件。最终的结果需要将多个值聚合成一个以进行排序。 开发一个基于梯度boosted回归树的模型来执行Elevation-aggregate。超参数的设置选择通过使用一个随机搜索的交叉验证方法：$losses ∈ {least \\ squares; least \\ absolute \\ deviation; Huber}$,$learning \\ rates \\in [1.0 × 10−6, 1.0]$ 在在对数空间中等间隔的100点,$the \\ number \\ of \\ estimators \\in [20, 50, 80, 100, 200, 300, 400, 500]$, 最大树深范围为 1 到 7, 最小分割样本数量 = [2, 3, 4], $splitting \\ criterion \\in [Friedman \\ mean-squared \\ error, mean-squared \\ error, mean absolute \\ error]$.","categories":[],"tags":[{"name":"note","slug":"note","permalink":"http://soufal.cn/tags/note/"}]},{"title":"Git笔记","slug":"Git笔记","date":"2018-06-16T06:13:42.000Z","updated":"2018-06-16T06:37:34.192Z","comments":true,"path":"2018/06/16/Git笔记/","link":"","permalink":"http://soufal.cn/2018/06/16/Git笔记/","excerpt":"","text":"Git分布式版本控制系统：学习廖雪峰的git教程 笔记( 图片转自廖雪峰 ）。 一、简介 随时掌握工作区的状态，使用git status命令。 如果git status 告诉你有文件被修改过，可以用git diff 查看修改内容。 在git中进行修改后可以保存一个快照，称为commit，如果文件被删除，可以通过最近一个commit恢复。 使用git log命令来查看历史记录。 --pretty=oneline参数简要输出相关信息。 回退到上一个版本： 在git中，HEAD表示当前版本，上一个版本就是HEAD^,上上个版本就是HEAD^^。（上100个版本HEAD~100。 把当前版本回退分层上一个版本，使用git reset --hard &lt;HEAD^&gt;命令。 回到未来的版本，使用git reset --hard &lt;commit ID&gt;(前提是命令行窗口未关闭，版本号可以写前几位即可） git reflog可以记录操作的每一条命令。 二、工作区和暂存区 工作区（working directory）创建的文件夹就是一个工作区。 版本库（Repository）：工作区中隐藏的目录.git是Git的版本库。版本库中存有（隐藏目录）： stage（index）暂存区 Git自动创建的第一个分支：master. 指向master的一个指针HEAD。 在往Git版本库中添加文件时，分两步执行： 1、用git add把文件加进去，实际上就是把文件修改添加到暂存区； 2、用git commit提交更改，实际上就是把暂存处的所有内容提交到当前分支master。 需要提交的文件修改后通通放到暂存区，然后，一次性提交暂存区的所有修改。 三、管理修改 Git跟踪并管理的是修改，而非文件。每次修改文件过后，如果不用git add将文件提交到暂存区，同样的文件也不会加入到commit中。 1、撤销更改在git add 之前发现文件修改有错，可以使用git checkout -- [filename]丢弃工作区的修改。命令git checkout -- readme.txt有两种情况：1、文件readme.txt自修改后还没有被放到暂存区，撤销修改就回到和版本库一模一样的状态。（还未使用git add）2、文件已经被添加到暂存区后，又做了修改，撤销修改就回到添加到暂存区后的状态。（已经使用了git add后对文件进行了修改）也就是让文件回到最近一次git commit或git add状态如果git checkout -- file命令没有使用--，就会变成“切换到另一个分支”的命令。 在修改文件并使用了git add将文件放到了暂存区后，可以使用git reset HEAD &lt;file&gt;命令可以把暂存区的修改撤销掉（unstage），重新将文件放回工作区。 四、删除文件当需要删除已给文件时，在工作区将文件删除后，需要从版本库删除文件git rm &lt;file&gt;。然后使用git commit -m &quot;&quot;进行提交，这样工作区和版本库都将该文件删除了。如果在工作区中删错了文件，可以使用git checkout -- &lt;file&gt;将误删的文件恢复到最新版本实际上该命令是用版本库里的版本替换工作区的版本。 五、远程仓库 关联github： 创建SSH Key：使用ssh-keygen -t rsa -C &quot;youremail@example.com&quot;创建秘钥。 进入.shh文件夹复制id_rsa.pub公钥中的内容到Github中的Add SSH Key中。如果有多台电脑，则可以在每一台电脑中生成一个新的Key并添加到github中。 添加远程库： 在github上新建一个仓库后，同本地已有的仓库关联，然后把本地仓库推送到Github库：使用git remote add origin https://github.com/soufal/my_git.git，这样添加后的远程库的名字就为origin，是git的默认叫法。 推送： 使用git push -u origin master把本地库的所有内容推送到远程库。这里使用加-u的命令是因为第一次推送master分支时，Git不但会吧本地的master分支内容推送到远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或拉取时就可以简化命令了。 从远程库克隆 可以现在Github上创建一个远程库new，再从远程库克隆到本地。使用git clone https://github.com/soufal/new.git或者git clone git@github.com:soufal/new.git。 两者的不同在于：前者使用的是https协议，速度较慢，每次推送都需要输入口令。后者使用的是SSH协议，其速度较快。 六、分支管理可以创建一个属于自己的分支，其他人看不到，还可以在原来的分支上继续工作，自己可以在自己的分支上继续工作。需要提交后再提交，可以一次性合并到原来的分支上。 1、创建于合并分支：在Git中，每一次的提交，Git都会把这些提交串成一条时间线，这条时间线就是一个分支。一直在使用的默认分支叫做主分支。即master分支。HEAD严格来说是指向master的，master才是指向提交的。所以可以说：HEAD指向的就是当前分支。一开始，master分支就是一条线，Git用master指向最新的提交，再用HEAD指向master，就可以确定当前分支以及当前分支的提交点： 当创建新的分支时dev时，git新建一个指针叫做dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上： 因此可以看出git创建一个分支很快，只需要增加一个指标dev，并修改HEAD的指向即可。修改过后，对工作区的修改和提交就只是针对dev分支了，而master指针不变： 如果在dev上的工作完成了，就可以将dev合并回master上。可以直接将master指向dev的当前提交（正如最开始创建分支一样），就完成了合并： 合并同样也很快，也只需要改指针。合并完成后，可以删除dev分支，也就是把dev指针删除，删除后就值剩下一个master分支。 2、相关命令： 创建dev：git checkout -b devgit checkout命令加上-b参数表示创建并切换。相当于: 12git branch dev git checkout dev 可以使用git branch查看当前分支。会列出所有的分支，当前分支前有一个*当完成工作提交后，通过git checkout master命令返回master分支。然后使用git merge dev把dev上的工作合并到master上。该指令用于合并指定分支到当前分支。 合并完成后使用git branch -d dev删除dev分支。 使用git log可以查看分支合并情况。 使用git log --graph乐意查看分支合并图。 3、分支管理策略 合并分支时，Git会用Fast forward模式，在这种模式下，删除分支后，会丢掉分支信息。 使用--no-ff方式的git merge会强制禁用Fast forward，这样git会在merge时生成一个新的commit，这样可以从分支历史上看出分支信息。 （创建新的commit可以用过加上-m参数实现） 在实际开发中，管理分支的几种原则： master分支应该是稳定的，也是仅仅用来发布新版本，平时不在其上进行工作。 工作都在dev分支上，因为dev是不稳定的。 可以在dev上再创建新的分支，和别人协同工作，最后再合并到dev上。如下图所示： Bug分支：Git提供了一个stash功能，可以把当前工作现场“储存”起来，等当前临时工作做完后再恢复现场继续工作： git stash。 确定bug需要在哪个分支上修复，就在那个分支上创建新的临时分支。 恢复工作区：使用git stash list查看之前隐藏的工作区。恢复方法有两种: 使用git stash apply恢复，但是恢复后，stash的内容并不删除，需要再使用git stash pop来删除。 使用git stash pop，恢复的同时会把stash的内容也删了。 可以多次stash，使用git stash list查看，然后恢复指定的stash。使用git stash apply stash@ {id}。","categories":[],"tags":[{"name":"note，git","slug":"note，git","permalink":"http://soufal.cn/tags/note，git/"}]},{"title":"第一篇","slug":"第一篇","date":"2018-06-13T02:13:26.000Z","updated":"2018-06-13T08:44:15.566Z","comments":true,"path":"2018/06/13/第一篇/","link":"","permalink":"http://soufal.cn/2018/06/13/第一篇/","excerpt":"","text":"这是一篇测试博客！","categories":[],"tags":[{"name":"note","slug":"note","permalink":"http://soufal.cn/tags/note/"}]}]}